\documentclass[12pt]{article}
\usepackage[portuguese]{babel}
\usepackage{natbib}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\graphicspath{{images/}}
\usepackage{parskip}
\usepackage{fancyhdr}
\usepackage{vmargin}
\usepackage{hyperref}
\usepackage{indentfirst}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=blue,
}

%%%%%%%%%%%%%%%%%%  For code %%%%%%%%%%%%%%%%%%
\usepackage{listings}
\renewcommand{\lstlistingname}{Código}
\renewcommand{\lstlistlistingname}{Lista de \lstlistingname s}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
%%%%%%%%%%%%%%%%%%  For code %%%%%%%%%%%%%%%%%%

\setmarginsrb{3 cm}{2.5 cm}{3 cm}{2.5 cm}{1 cm}{1.5 cm}{1 cm}{1.5 cm}
\setlength{\parindent}{6ex}
\date{\today}											% Date

\makeatletter

\let\thedate\@date
\makeatother

\pagestyle{fancy}
\fancyhf{}
\rhead{\theauthor}
\lhead{\thetitle}
\cfoot{\thepage}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}
	\centering
    \vspace*{0.5 cm}
    \includegraphics[scale = 0.6]{pics/logo_UA.png}\\[1.0 cm]	% University Logo
    \textsc{\LARGE Universidade de Aveiro }\\[2.0 cm]
	\textsc{\Large Segurança Informática nas Organizações}\\[0.5 cm]
	\rule{\linewidth}{0.2 mm} \\[0.4 cm]
	{ \huge \bfseries {Sistema de Leilões}}\\[0.5 cm]
	\textsc{\Large Relatório Final}\\	
	\rule{\linewidth}{0.2 mm} \\[1.5 cm]
	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft} \large
			\emph{Autores :}\\
			{84793 \quad Daniel Nunes}\\	
			{84921 \quad Rafael Direito}	
	    \end{flushleft}
	\end{minipage}
	\begin{minipage}{0.4\textwidth}
		\begin{flushright} \large
			\emph{Professores :} \\
			{João Paulo Barraca}\\
			{Vitor Cunha}
		\end{flushright}
	\end{minipage}\\[2 cm]
	
	\vspace*{\fill}
	{\large \thedate}
 
	\vfill
	
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\pagebreak

\listoffigures
\pagebreak


\lstlistoflistings
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introdução}
Inserido no plano curricular da disciplina de Segurança Informática e Nas Organizações, do curso de Engenharia Informática, da Universidade de Aveiro e lecionada pelos professores João Paulo Barraca e Vítor Cunha, este relatório é proveniente da execução do projeto final da cadeira.
\par Este projeto consiste num sistema de leilões onde um cliente pode criar leilões, participar em leilões e no final observar o resultado do leilão criado. Todas as comunicações neste sistema são seguras e todas as licitações podem ser validadas no final do leilão, através da comparação com os recibos de cada cliente.
\clearpage


\section{Processos}
\subsection{Proteção (Encriptação, Autenticação e Integridade) das Mensagens Trocadas}

\par Todas as mensagens são trocadas no formato json utilizando uma chave ‘type’, que indica o propósito da mensagem, sendo que para o  envio das mensagens são utilizadas sockets. 


\noindent Relativamente à proteção das mensagens podemos distinguir 2 cenários diferentes:
\begin{itemize}
  \item Mensagens entre os clientes e o repositório.
  \item Mensagens entre o repositório e o leiloeiro.
\end{itemize}

\subsubsection{Mensagens entre os clientes e o repositório}

\par Relativamente ao primeiro cenário, utilizamos uma cifra híbrida, de forma a partilhar as chaves da nova sessão a estabelecer. Desta forma, iremos trocar uma chave AES-CCM que, para além de encriptar as mensagens, garante a integridade das mesmas.
\par Entre o cliente e o repositório existe uma mensagem inicial onde vai ser trocada a AES-CCM (ver \href{https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/}{Chaves Simétricas}) para comunicação entre os mesmos. 
\newline
A partir desta mensagem, as mensagens seguintes passam todas a ser encriptadas pela chave trocada. 

\vspace{5mm} %5mm vertical space
\noindent \underline{Procesos e Interações:}
\begin{enumerate}
    \item O cliente, aquando da ligação ao repositório, gera uma \textit{key} e um  \textit{nonce} AES-CCM .
    \item O cliente encripta a \textit{key} e o \textit{nonce} com a chave pública do repositório obtida através do certificado do repositório. Desta forma garantimos que a mensagem apenas poderá ser decifrada pelo repositório.
    \item A \textit{key} e o \textit{nonce} são assinados através do Cartão de Cidadão garantindo a autenticidade dos mesmos.
    \item O certificado do Cartão de Cidadão deverá ser enviado para validação das assinaturas no lado do repositório.
    \item O repositório valida o certificado (com a construção da cadeia de certificados) assim como da assinatura feita na \textit{key} e no \textit{nonce}.
    \item O Repositório decifra a \textit{key} e o \textit{nonce}  com a sua chave privada.
    \item O Repositório gera um \textit{session id}
    \item O Repositório encripta o \textit{session id} com uma cifra AES-CCM (cuja \textit{key} foi recebida previamente e o \textit{nonce} gerado aleatoriamente) e envia este \textit{id} para o cliente.
\end{enumerate}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.85\textwidth]{pics/sessaoClienteRepositorio.png}
    \caption{Estabelecimento de uma Sessão Segura entre o Cliente e o Repositório}
\end{figure}




\vspace{5mm} %5mm vertical space

A partir deste momento, todas as mensagens entre o cliente e o repositório serão encriptadas com recurso à \textit{key} trocada e a um \textit{nonce} aleatório enviado em todas as mensagens. Este processo aumenta a dificuldade de descobrir a  \textit{session key}.

\subsubsection{Mensagens entre o repositório e o leiloeiro}


\par A segurança da comunicação entre o repositório e o leiloeiro é garantida através de um canal seguro TLS.
\par Para tal, implementámos uma autenticação mútua com certificados gerados com \textit{openssl}. Estes são assinados por uma Entidade Certificadora, garantido a validade de ambos. Sempre que se inicia a comunicação entre o repositório e o leiloeiro os certificados são trocados e é avaliada a sua validade, tendo em conta a sua cadeia entidades certificadoras - neste caso, apenas uma.
\par O canal de TLS, para além de garantir um canal seguro de troca de mensagens, permite também a autenticidade das mensagens, bem como a sua integridade.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.65\textwidth]{pics/tls-hs.png}
    \caption{Protocolo TLS}
\end{figure}





\subsection{Proteção das \textit{bids} até ao fim do leilão}

\par Relativamente a um leilão, todos as \textit{bids} se encontram protegidas através do uso de cifra híbrida. 
\par Dinamicamente, o criador de um dado leilão pode definir quais os campos de uma bid que pretende que sejam encriptados até ao final deste. Assim sendo, aquando da criação de um leilão, o criador vai gerar um par de chaves assimétricas (RSA). A chave pública irá ser inserida no bloco inicial da \textit{blockchain} e será utilizada por todos os participantes do leilão para encriptar os campos definidos no leilão. Estes devem, sempre que inserem uma nova \textit{bid}, consultar o bloco inicial e obter esta chave. Já a chave privada irá ser guardada pelo criador (esta será utilizada no final do leilão, como será posteriormente descrito). 
\par Para que o criador do leilão não possa decriptar as \textit{bids}, tendo assim acesso privilegiado, o leiloeiro, aquando da validação das bids, irá encriptar os campos com uma cifra AES-CCM gerada para o efeito. A chave associada a esta cifra irá ser guardada pelo manager, contudo, sempre que este cifrar uma nova bid, irá adicionar o \textit{nonce} ao novo bloco, para que posteriormente o possa utilizar e desencriptar os campos encriptados.





\subsection{Identificação do autor de cada \textit{bid} com o Cartão de Cidadão}

\par De forma a autenticar as \textit{bids}, o valor destas será sempre assinado pelo cliente, com recurso ao seu Cartão de Cidadão. Juntamente com a  \textit{bid} assinada, será ainda enviado o certificado que contém a chave pública associada ao cliente em questão. Este será encriptado com recurso a uma cifra AES-CCM.

\par Isto acontece uma vez que, devido ao seu elevado tamanho, o certificado não poderá ser assinado com uma cifra assimétrica RSA.

\par  Tanto a \textit{key} como o \textit{nonce} gerados para a cifra AES serão posteriormente encriptados com a chave pública associado ao leilão (que pode ser encontrada no primeiro bloco da \textit{blockchain} do mesmo) e, já na validação da \textit{bid} pelo leiloeiro, encriptados com a sua cifra AES-CCM.

\par Relativamente às assinaturas utilizámos \textit{PCKS\#11}, assinando as bids com a chave contida no Cartão de Cidadão Português. Desta forma, validando a assinatura presente em cada bloco, através da chave pública contida no certificado do Cartão de Cidadão, podemos verificar qual o utilizador que submeteu cada bid.

\par Para utilizar o certificado acima referido como forma de verificar uma assinatura será necessário validar toda a sua cadeia de entidades certificadoras (\textit{CAs}).

\vspace{8mm} %5mm vertical space



\begin{lstlisting}[caption={Assinatura com Recurso ao Cartão de Cidadão},captionpos=b]
mechanism = PyKCS11.Mechanism(PyKCS11.CKM_SHA1_RSA_PKCS, None)
signature = None
    try:
        signature = bytes(session.sign(private_key, message, mechanism))
    except:
        # error solving code
\end{lstlisting}


\subsection{Revelar as \textit{bids} no final do leilão}

\par Aquando o final do leilão, o criador do mesmo irá ter que colocar a chave privada RSA que criou para o mesmo no último bloco da \textit{blockchain}. Contudo, esta chave por si só não é suficiente para decriptar todas as bids do leilão, uma vez que estas foram também encriptadas pelo manager. Desta forma, também este irá ter de colocar a sua chave simétrica (AES) no último bloco da \textit{blockchain}, fechando-a.

\par Cada utilizador terá, então, que utilizar estas 2 chaves para desencriptar toda a blockchain e verificar a validade da mesma, podendo verificar se os seu recibos estão na blockchain, bem como saber quem foi o vencedor do leilão.







\subsection{Validação das \textit{bids} com recurso a código dinâmico}

\par Sempre que se inicia um leilão, o seu criador terá de enviar um ficheiro em \textit{python} com o código de validação das bids efetuadas.  Esta metodologia permite que as bids sejam validadas dinamicamente, de acordo com a preferência do criador do leilão.

\par Posteriormente, o código inserido pelo criador será enviado para o leiloeiro, através do repositório. O leiloeiro reconstrói o código num ficheiro \textit{python}  e irá executá-lo com  recurso ao \textbf{exec(...)} do \textit{python}. Neste processo, é essencial definir que variáveis e \textit{imports} podem ser utilizados dentro do código \textit{python} a ser executado. Assim, não se deve permitir o acesso a, por exemplo, funções do módulo \textit{os}.

\par Desta forma, implementámos a nossa solução respeitando o descrito acima.
\par Ao executarmos o ficheiro de validação fornecemos-lhe variáveis globais e locais, consoante a sua utilização.

\vspace{5mm} %5mm vertical space

\begin{lstlisting}[caption={Execução de Código Dinâmico},captionpos=b]
exec(open("./validation_"+str(message['auction_id'])+".py").read(), variables4validation, script_locals)
\end{lstlisting}






\subsection{Modificação das \textit{bids} com recurso a código dinâmico}

\par Após a validação das \textit{bids}, o criador do leilão poderá também executar algumas modificações nas mesmas, através de código dinâmico. A sua utilização segue as mesmas premissas descritas acima.

\par No caso da nossa solução, geralmente optamos por enviar código dinâmico que defina a dificuldade de realização do \textit{cryptopuzzle} associado a cada bloco, permitindo aumentar a dificuldade de inserção de blocos consoante o número de \textit{bids} existentes. 

\par Contudo, o utilizador poderá optar por enviar código que realize outra função.

\vspace{5mm} %5mm vertical space

\begin{lstlisting}[caption={Exemplo de uma Função de Modificação Dinâmica},captionpos=b]
block = None
blockchain = None

def change():
	l = len(blockchain.content)
	difficulty = (1/(-(l+ ((4 * blockchain.content[0].puzzle_difficulty) + 1)))*5) + 4
	difficulty = round(difficulty)
	block.data["puzzle_difficulty"] = difficulty
	return block, difficulty

block, difficulty = change()
\end{lstlisting}







\subsection{Construção da \textit{blockchain} associada a um leilão}

\par Cada leilão está implementado com recurso a uma \textit{blockchain}. Esta permite que cada utilizador valide a autenticidade e a validade de cada bloco da mesma. 

\par Nesta, encontramos diversos blocos, cada um com informação acerca de uma \textit{bid}. Estes contêm referências para os seu bloco pai (como se tratasse de uma \textit{linked list}), o que permite verificar a ordem pelos quais foram inseridos. Em última instância, caso um bloco tenha sido alterado após a sua inserção, um utilizador conseguirá verificar a ocorrência deste evento.

\vspace{5mm} %5mm vertical space

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.6\textwidth]{pics/blockchain.png}
    \caption{\textit{Blockchain}}
\end{figure}

\par Sempre que é inserido um novo bloco, o utilizador poderá verificar a integridade de toda a cadeia, que, caso tenha sido quebrada em algum momento, torna-se inválida, sendo que os dados contidos nesta deixarão de ser confiáveis.
\vspace{25mm} %5mm vertical space


\par Segue-se o código associado a cada bloco da cadeia:

\vspace{5mm} %5mm vertical space

\begin{lstlisting}[caption={Classe Block},captionpos=b]
class Block:
    def __init__(self, prev_index, data, parent_hash):
        self.index = prev_index + 1
        # contains the key pair user-bid
        self.data = data
        self.puzzle_solution = None
        self.puzzle_difficulty = 1
        self.parent_hash = parent_hash
        self.nonce = int.from_bytes(os.urandom(8),  byteorder="big")
        self.timestamp = date.datetime.now()
    
    def __setattr__(self, name, value):
        # records every time an element has been touched
        if name != "timestamp":
           self.timestamp = date.datetime.now()
        self.__dict__[name] = value

\end{lstlisting}







\subsection{Deployment dos \textit{cryptopuzzles}}

\par No contexto da nossa solução, podemos definir um \textit{crypopuzzle} como sendo um desafio enviado para o cliente, pelo servidor. O cliente, terá que resolver este desafio (\textit{proof of work}) e incluir a sua solução na resposta ao servidor, que posteriormente verificará se esta está correta.

\par Este mecanismo permite, também, diminuir a carga temporal de \textit{requests} do servidor, uma vez que um \textit{crypopuzzle} poderá demorar alguns segundos a ser resolvido, consoante a dificuldade exigida pelo servidor. Mais ainda, este poderá aumentar a dificuldade dos \textit{crypopuzzle}, de forma a acompanhar o número crescente de \textit{requests}.

\par Na solução implementada, aquando a inserção de um novo bloco na \textit{blockchain} o cliente terá que resolver um \textit{crypopuzzle} e incluir a sua solução no mesmo, que posteriormente será verificada, sendo este um fator importante para a validade da \textit{blockchain}. Assim, o utilizador recebe um bloco com um \textit{nonce random}, que irá incrementar até que a síntese do bloco se inicie por um conjunto de \textit{bits} pré-definido.

\par Quando se verificar a condição descrita, a solução é colocada no bloco e enviada ao repositório que avaliará a sua veracidade, com base num processo bastante menos moroso, uma vez que não tem necessidade de calcular \textit{nonces}. 

\vspace{5mm} %5mm vertical space

\begin{lstlisting}[caption={Função Utilizada Para Resolver um \textit{Cryptopuzzle}},captionpos=b]
def solve(difficulty, block_json):
   solution =  hash_function(json.dumps(block_json))
   while solution[:difficulty] != "1"*difficulty:
       block_json["Nonce"] += 1
       block_json["Timestamp"] = str(datetime.now())
       solution = hash_function(json.dumps(block_json))
   block_json["Solution"] = solution
   return block_json
\end{lstlisting}






\subsection{Produção e validação dos recibos}

\par Quando o repositório recebe o bloco com a solução do \textit{crypopuzzle}, este valida-a e, caso esta esteja correta, insere o bloco na \textit{blockchain} guardando neste o seu local de inserção, o seu bloco pai e o momento em que foi inserido na \textit{chain}.

\par Posteriormente, como recibo, o repositório irá enviar o bloco inserido ao cliente. Este bloco contém informações encriptadas pelo leiloeiro e será assinado pelo repositório, de forma a garantir a autenticidade do mesmo. A assinatura do repositório assegura, também, a integridade do recibo.

\par Posteriormente, o recibo será recebido pelo cliente, que validará a assinatura do repositório e confirmará se os dado enviados por si, são aqueles que constam no recibo.

\par Se estas condições se verificarem, o recibo é considerado válido e é guardado em disco.

\par Posteriormente, quando a \textit{blockchain} for decifrada, o utilizador poderá verificar todos os seus recibos.

\vspace{5mm} %5mm vertical space

\begin{lstlisting}[caption={Inserção de um Bloco na  \textit{Blockchain} e Posterior Envio do Recibo do Mesmo },captionpos=b]
# get blockchain and insert new block, validating it
bc = myAuction.auctions[auction_id][0]
ret = bc.insert_solved_block(tmp_block)

signature = myAuction.repository_pvk.sign(
   bytes(ret.puzzle_solution, 'utf-8'),
   padding.PSS(
       mgf=padding.MGF1(hashes.SHA256()),
       salt_length=padding.PSS.MAX_LENGTH
   ),
   hashes.SHA256()
)

# sign block and return it as a receipt
b = ret.to_json()
b["Solution"] = ret.puzzle_solution

return {"block" : json.dumps(b), "solution": ret.puzzle_solution, "signature" : base64.b64encode(signature).decode()}
\end{lstlisting}




\subsection{Validação de um Leilão Fechado (Por um Cliente)}

\par No fim de um leilão, o criador do leilão e o leiloeiro inserem as suas chaves do leilão na \textit{blockchain} (como descrito anteriormente), o que permite que um cliente consiga decifrar a totalidade da \textit{blockchain}.

\par Após este processo, o cliente poderá validar a \textit{blockchain} tendo em conta:
\begin{itemize}
  \item \textbf{Autenticidade de cada \textit{bid}:} cada cliente poderá verificar se a assinatura de uma \textit{bid} é válida, através do uso da chave pública contida no certificado associado à \textit{bid}.
  \item \textbf{Soluções dos \textit{cryptopuzzles}:} o cliente poderá resolver eficientemente o \textit{cryptopuzzle} associado a cada bloco e verificar se a solução do mesmo se encontra associada a este.
  \item \textbf{Validação da ordem das \textit{bids}: } Através das ligações estabelecidas entre  os blocos é possível validar a ordem pela qual foram inseridos estes blocos.
\end{itemize}

\par Se conseguirmos validar todos os aspectos referidos acima, para cada bloco, então podemos considerar a \textit{blockchain} como válida.

\vspace{5mm} %5mm vertical space

\begin{lstlisting}[caption={Validação da  \textit{Blockchain}},captionpos=b]
flag = True
deciphered_bids = []
for i in range(len(chain)):
   if "owner_key" in last_block[1]["Data"]:
       validation = validate_block(chain,i, AESCCM(manager_key), owner_key, cipher_fields)
       if i != 0  and i != len(chain) -1 :
           block = copy.copy(chain[i][1])
           if len(validation) > 2:
               block["Data"]["user"] = validation[2][0]
               block["Data"]["bid"] = validation[2][1]
               deciphered_bids.append(block)
       else:
           deciphered_bids.append(copy.copy(chain[i][1]))
   else:
       validation = validate_block(chain,i,None, None, None)
   flag = flag and validation[0]
return flag
\end{lstlisting}



\pagebreak

\section{Extras}

\subsection{Autenticação de 2 fatores}

\par De forma a garantir maior segurança na autenticação do cliente no servidor, este poderá enviar ao cliente uma \textit{OTP}, via \textit{SMS}.

\par Esta funcionalidade está implementada com uma api externa - \href{https://portal.sinch.com}{Sinch}. 
De momento, apenas estamos a providenciar o envio de \textit{OTPs} para um número de telefone pré-definido, uma vez que o Cartão de Cidadão Português não tem nenhum número de telemóvel associado a um cidadão.

\par Contudo, esta solução poderia ser implementada com \textit{smartcards} que guardassem o contacto do seu \textit{owner}.

\par Relativamente à sua implementação, para que o repositório peça ao utilizar uma autenticação dupla, temos de iniciar este servidor com:

\vspace{5mm} %5mm vertical space

\begin{lstlisting}
python3 auction_repository two_factor
\end{lstlisting}

\par Assim que o cliente iniciar uma conexão ao repositório este vai avaliar se irá ser necessária uma \textit{OTP} e envia esta informação ao cliente. Ao mesmo tempo, envia um \textit{SMS} com a \textit{OTP} escolhida aleatoriamente.

\vspace{5mm} %5mm vertical space

\begin{lstlisting}[caption={Verificação e Envio da \textit{OTP} via \textit{SMS} },captionpos=b]
if message["type"] == "otp_needed":
    if len(sys.argv) > 1 and sys.argv[1] == "two_factor":
        # define session OTP
        otp = ""
        while len(otp) < 6:
            n = secrets.randbelow(10)
            otp += str(n)
        
        myAuction.otp = otp

        # send sms to client
        number = '+351911111111'
        m = "OTP to access repository: " + otp
        client = SinchSMS("41da1648-fe23-49d2-9ff6-77d85ab9fe03", "fZmQ4p54RE6oDiklITnS6w==")

        print("Sending '%s' to %s" % (m, number))
        r = client.send_message(number, m)  

        # enviar resposta 
        resp = {'response' : 'yes'}
        resp = json.dumps(resp)
        conn.send(bytes(resp, 'utf-8'))
    else:
        # enviar resposta 
        resp = {'response' : 'no'}
        resp = json.dumps(resp)
        conn.send(bytes(resp, 'utf-8'))
\end{lstlisting}






\subsection{\textit{TLS} entre repositório e leiloeiro}

\par A segurança da comunicação entre o repositório e o leiloeiro é garantida através de um canal seguro \textit{TLS}.

\par Para tal, implementámos uma autenticação mútua com certificados gerados com \textit{openssl}. Estes são assinados por uma Entidade Certificadora, garantido a validade de ambos. Sempre que se inicia a comunicação entre o repositório e o leiloeiro, os certificados são trocados e é avaliada a sua validade, tendo em conta a sua cadeia de entidades certificadoras - neste caso, apenas uma.

\par O canal de \textit{TLS}, para além de garantir um canal seguro de troca de mensagens, permite também a autenticidade das mensagens, bem como a sua integridade.

\vspace{5mm} %5mm vertical space

\begin{lstlisting}[caption={Autenticação Mútua entre o Repositório e o Leiloeiro com Recurso a \textit{TLS}},captionpos=b]
def connect_manager():
    man_addr = '127.0.0.1'
    man_port = 8080
    server_hostname = 'localhost'
    server_ca = 'sioCACertificate.pem'
    client_key = 'repositoryKey.key'
    client_cert = 'repositoryCertificate.pem'
    context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
    context.verify_mode = ssl.CERT_REQUIRED
    context.load_cert_chain(certfile=client_cert, keyfile=client_key)
    context.load_verify_locations(cafile=server_ca)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    man_conn =  context.wrap_socket(s, server_side=False, server_hostname=server_hostname)
    man_conn.connect((man_addr, man_port))
    return man_conn

man_conn = connect_manager()
\end{lstlisting}





\subsection{Encriptação de Ficheiros}

\par Relativamente aos recibos das \textit{bids} de cada cliente, estes estão a ser guardados localmente, em disco, num diretório comum. Assim, de forma a que os clientes não consigam ver os recibos de outros clientes, desenvolvemos uma solução que encripta os ficheiros dos recibos de cada clientes.

\par Desta forma, usando o \textit{7zip} encriptam-se, não só os recibos das \textit{bids}, mas também as chaves que cada cliente cria para os leilões que este inicia. 

\par Sempre que um cliente se autentica, é lhe pedida a \textit{password} associada aos ficheiros, sendo que estes serão posteriormente comprimidos num zip, que será encriptado e desencriptado consoante a necessidade de escrever nos ficheiros que este contém.

\vspace{5mm} %5mm vertical space

\begin{lstlisting}[caption={Encriptação e Decriptação de Ficheiros},captionpos=b]
import subprocess, shutil
from os import listdir, remove, _exists
import os
from os.path import isfile, join


def unzip(serial_number, pw):
    cmd = ['7z', 'x', serial_number + '.zip', '-o'+serial_number, '-p'+ pw]

    p = subprocess.Popen(cmd, stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
    p.communicate()
    folder = serial_number
    onlyfiles = [f for f in listdir(folder) if isfile(join(folder, f))]
    for f in onlyfiles:
        cmd = ['mv', folder+'/'+f, '.']
        p = subprocess.Popen(cmd, stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
        p.communicate()
    shutil.rmtree(folder)
    os.remove(os.path.join('.', serial_number + '.zip'))
    
def zzip(serial_number, pw):
    cmd = ['7z', 'a', serial_number + '.zip', '-p' + pw, '-y', serial_number+'*']
    p = subprocess.Popen(cmd, stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
    p.communicate()
    for fname in os.listdir('.'):
        if fname.startswith(serial_number) and not fname.endswith('.zip'):
            os.remove(os.path.join('.', fname))

\end{lstlisting}







\subsection{Guardar leilões em disco}

\par De forma a prevenir que todos os leilões efetuados se percam no caso do repositório \textit{crashar}, estes são guardados num ficheiro local.

\par Assim, utilizámos a biblioteca \textit{pickle} para serializar a classe \textit{python} que guarda todos os leilões, guardando esta informação num ficheiro local. Sempre que o repositório é iniciado, este tem em atenção os leilões previamente existentes.

\par Uma vez que há classes que não são serializáveis com o \textit{pickle} - como é o caso de certificados do Cartão de Cidadão -, será necessário serializá-las “manualmente”.


\vspace{5mm} %5mm vertical space

\begin{lstlisting}[caption={Escrita e Leitura de Ficheiros com a Biblioteca \textit{Pickle}},captionpos=b]
def load_pickle(f):
   # Load Pickle File
   my_file = Path(f)
   if my_file.is_file():
       myAuction = pickle.load( open(f,"rb") )
       # reconvert
       myAuction.repository_pvk = serialization.load_pem_private_key(
           myAuction.repository_pvk,
           password=None,
           backend=default_backend()
       )
   else:
       myAuction = AuctionInfo()

   return myAuction

def save_pickle(f):
   pem = myAuction.repository_pvk.private_bytes(
       encoding=serialization.Encoding.PEM,
       format=serialization.PrivateFormat.TraditionalOpenSSL,
       encryption_algorithm=serialization.NoEncryption()
   )
   tmpkey = copy.copy(myAuction.repository_pvk)

   myAuction.repository_pvk = pem
   pickle_file = open("auction.pickle","wb")
   pickle.dump(myAuction, pickle_file)
   pickle_file.close()
   myAuction.repository_pvk = tmpkey

\end{lstlisting}





\subsection{Leilão \textit{single bid}}

\par De forma a aumentar o conjunto de leilões disponíveis, criámos código para a realização/validação de um leilão \textit{single bid}.

\par Neste tipo de leilão cada utilizador apenas poderá submeter uma bid.


\pagebreak

\section{Esquemas de apoio}

\vspace{5mm} %5mm vertical space

\begin{figure}[h!]
    \centering
    \includegraphics[width=1\textwidth]{pics/submissaoBid.png}
    \caption{Submissão de uma \textit{bid}}
\end{figure}




\pagebreak

\section{Informação adicional}

Para poder utilizar a nossa solução é necessário abrir 3 terminais diferentes, um para cada actor do sistema, de acordo com a seguinte ordem:


\vspace{5mm} %5mm vertical space
\begin{enumerate}
    \item Leiloeiro - deve ser executado com \textbf{\textit{python3 auction\_manager.py}}
    
    \item Repositório - deve ser executado com \textbf{\textit{python3 auction\_repository.py}} ou com \textbf{\textit{python3 auction\_repository two\_factor.py}}, caso se deseje utilizar autenticação de 2 fatores ao nível do repositório.
    
    \item Cliente - deve ser executado com \textbf{\textit{python3 client.py}}
\end{enumerate}
\vspace{5mm} %5mm vertical space

Todo o código pode ser encontrado num repositório do CodeUA. É possível fazer \textit{clone} do repositório com o seguinte comando:  \textbf{\textit{git clone  https://code.ua.pt/git/sio2018-p1g21}}

\pagebreak

\section{Conclusão}

\par Olhando em retrospectiva, consideramos que todos os objetivos relativos a este projeto foram atingidos. Sendo assim, e através de uma análise cuidada ao entregável final, pensamos que conseguimos implementar todas as funcionalidades que inicialmente projetámos. 

\par Em suma, concluímos que, com este projeto, os conhecimentos na área de segurança, quer no seu planeamento, quer na sua efetiva implementação foram, sem qualquer dúvida, melhorados e que a capacidade de pesquisa e autonomia foram, também elas, bem desenvolvidas, na tentativa de obter soluções face aos problemas encontrados.

\pagebreak

\bibliographystyle{plain}

\bibliography{biblist}

\vspace{5mm} %5mm vertical space


[1] ZÚQUETE, André Ventura. \textbf{Segurança em Redes Informáticas}. 4ª Edição. FCA - Editora de Informática 


[2] \url{https://www.ibm.com/support/knowledgecenter/en/SSFKSJ\_7.1.0/com.ibm.mq.doc/sy10670\_.htm}

[3] \url{https://docs.python.org/3/library/ssl.html#ssl-security}

[4] \url{https://deliciousbrains.com/ssl-certificate-authority-for-local-https-development/}

[5] \url{https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa/?highlight=rsa}

[6] \url{https://cryptography.io/en/latest/hazmat/primitives/padding/}

[7] \url{https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/}

[8] \url{https://medium.com/coinmonks/a-laymans-explanation-of-public-key-cryptography-and-digital-signatures-1090d4bd072e}

[9] \url{https://towardsdatascience.com/blockchain-explained-in-7-python-functions-c49c84f34ba5}

[10] \url{https://www.pythonsheets.com/notes/python-security.html}

\end{document}